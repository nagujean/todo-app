rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // ============================================
    // SECTION 1: Input Validation Functions
    // ============================================

    // Validate string is not empty and within length limits
    function isValidString(value, minLen, maxLen) {
      return value is string &&
        value.size() >= minLen &&
        value.size() <= maxLen;
    }

    // Validate string contains no dangerous HTML/script characters (XSS prevention)
    function isSafeString(value) {
      return value is string &&
        !value.matches('.*<script.*') &&
        !value.matches('.*<iframe.*') &&
        !value.matches('.*javascript:.*') &&
        !value.matches('.*onerror=.*') &&
        !value.matches('.*onclick=.*') &&
        !value.matches('.*onload=.*');
    }

    // Validate email format
    function isValidEmail(email) {
      return email is string &&
        email.matches('^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$') &&
        email.size() <= 254;
    }

    // Validate timestamp is current (within 5 minutes tolerance)
    function isCurrentTimestamp(ts) {
      return ts is timestamp &&
        ts >= request.time - duration.value(5, 'm') &&
        ts <= request.time + duration.value(1, 'm');
    }

    // Validate role is one of the allowed values
    function isValidRole(role) {
      return role in ['owner', 'admin', 'editor', 'viewer'];
    }

    // Validate todo priority
    function isValidPriority(priority) {
      return priority in ['low', 'medium', 'high', 'urgent'];
    }

    // Validate invitation type
    function isValidInvitationType(type) {
      return type in ['email', 'link'];
    }

    // Validate invitation status
    function isValidInvitationStatus(status) {
      return status in ['pending', 'accepted', 'declined', 'expired', 'cancelled'];
    }

    // ============================================
    // SECTION 2: Audit Logging Helper Functions
    // ============================================

    // Validate required audit fields on create
    function hasCreateAuditFields() {
      return request.resource.data.createdAt is timestamp &&
        request.resource.data.createdBy == request.auth.uid &&
        isCurrentTimestamp(request.resource.data.createdAt);
    }

    // Validate required audit fields on update
    function hasUpdateAuditFields() {
      return request.resource.data.updatedAt is timestamp &&
        request.resource.data.lastModifiedBy == request.auth.uid &&
        isCurrentTimestamp(request.resource.data.updatedAt);
    }

    // Validate soft delete fields
    function hasValidSoftDeleteFields() {
      return request.resource.data.isDeleted == true &&
        request.resource.data.deletedAt is timestamp &&
        request.resource.data.deletedBy == request.auth.uid &&
        isCurrentTimestamp(request.resource.data.deletedAt);
    }

    // Check if document is soft-deleted
    function isNotSoftDeleted() {
      return !('isDeleted' in resource.data) || resource.data.isDeleted != true;
    }

    // Ensure immutable fields are not modified
    function preservesImmutableFields(fields) {
      return !request.resource.data.diff(resource.data).affectedKeys().hasAny(fields);
    }

    // ============================================
    // SECTION 3: Authentication & Role Functions
    // ============================================

    // Check if user is authenticated
    function isSignedIn() {
      return request.auth != null;
    }

    // Check if user is a member of the team (and team is not deleted)
    function isTeamMember(teamId) {
      return isSignedIn() &&
        exists(/databases/$(database)/documents/teams/$(teamId)/members/$(request.auth.uid)) &&
        (!exists(/databases/$(database)/documents/teams/$(teamId)) ||
         !('isDeleted' in get(/databases/$(database)/documents/teams/$(teamId)).data) ||
         get(/databases/$(database)/documents/teams/$(teamId)).data.isDeleted != true);
    }

    // Get user's role in the team
    function getTeamRole(teamId) {
      return get(/databases/$(database)/documents/teams/$(teamId)/members/$(request.auth.uid)).data.role;
    }

    // Check if user is team owner
    function isTeamOwner(teamId) {
      return isTeamMember(teamId) && getTeamRole(teamId) == 'owner';
    }

    // Check if user is team admin (owner or admin)
    function isTeamAdmin(teamId) {
      return isTeamMember(teamId) && getTeamRole(teamId) in ['owner', 'admin'];
    }

    // Check if user can edit team todos (owner, admin, or editor)
    function canEditTeamTodos(teamId) {
      return isTeamMember(teamId) && getTeamRole(teamId) in ['owner', 'admin', 'editor'];
    }

    // ============================================
    // SECTION 4: Rate Limiting Functions
    // ============================================
    // Note: True rate limiting requires server-side logic.
    // These functions provide document-count-based limits.

    // Count user's active teams (limit: 10 teams per user)
    function getUserTeamCount() {
      // This is a conceptual limit - actual enforcement requires
      // tracking in a separate counter document or Cloud Functions
      return true;
    }

    // Validate invitation creation rate limit metadata
    // Requires client to maintain invitationsCreatedToday counter
    function isWithinInvitationRateLimit() {
      // Rate limit: max 20 invitations per day per user
      // Client must track and include invitationCount in request
      return !('invitationCount' in request.resource.data) ||
        request.resource.data.invitationCount <= 20;
    }

    // ============================================
    // SECTION 5: Rate Limit Counter Collection
    // ============================================

    match /rateLimits/{userId} {
      // Only the user can read their own rate limits
      allow read: if isSignedIn() && request.auth.uid == userId;

      // Only server-side (Cloud Functions) should update rate limits
      // Client can create initial document
      allow create: if isSignedIn() &&
        request.auth.uid == userId &&
        request.resource.data.keys().hasOnly(['teamsCreated', 'invitationsCreatedToday', 'lastInvitationDate', 'createdAt']);

      // Update only allowed for incrementing counters with validation
      allow update: if isSignedIn() &&
        request.auth.uid == userId &&
        // Can only increment, not decrease
        request.resource.data.teamsCreated >= resource.data.teamsCreated &&
        // Max 10 teams per user
        request.resource.data.teamsCreated <= 10 &&
        // Max 20 invitations per day
        (request.resource.data.invitationsCreatedToday <= 20 ||
         // Reset counter if new day
         request.resource.data.lastInvitationDate != resource.data.lastInvitationDate);
    }

    // ============================================
    // SECTION 6: User Rules
    // ============================================

    match /users/{userId} {
      // Read: only own data, must be authenticated
      allow read: if isSignedIn() && request.auth.uid == userId;

      // Create: user can create their own profile with required fields
      allow create: if isSignedIn() &&
        request.auth.uid == userId &&
        // Required fields
        request.resource.data.keys().hasAll(['email', 'createdAt']) &&
        // Validate email
        isValidEmail(request.resource.data.email) &&
        // Validate display name if provided
        (!('displayName' in request.resource.data) ||
          (isValidString(request.resource.data.displayName, 1, 100) &&
           isSafeString(request.resource.data.displayName))) &&
        // Audit fields
        isCurrentTimestamp(request.resource.data.createdAt);

      // Update: user can update own profile with audit fields
      allow update: if isSignedIn() &&
        request.auth.uid == userId &&
        // Validate display name if provided
        (!('displayName' in request.resource.data) ||
          (isValidString(request.resource.data.displayName, 1, 100) &&
           isSafeString(request.resource.data.displayName))) &&
        // Preserve immutable fields
        preservesImmutableFields(['email', 'createdAt']) &&
        // Require update audit fields
        request.resource.data.updatedAt is timestamp &&
        isCurrentTimestamp(request.resource.data.updatedAt);

      // Delete: not allowed (use soft delete)
      allow delete: if false;

      // ----------------------------------------
      // User Todos Subcollection
      // ----------------------------------------
      match /todos/{todoId} {
        // Read: only non-deleted todos
        allow read: if isSignedIn() &&
          request.auth.uid == userId &&
          isNotSoftDeleted();

        // Create: with validation and audit fields
        allow create: if isSignedIn() &&
          request.auth.uid == userId &&
          // Required fields
          request.resource.data.keys().hasAll(['title', 'completed', 'createdAt', 'createdBy']) &&
          // Validate title (1-500 chars, safe string)
          isValidString(request.resource.data.title, 1, 500) &&
          isSafeString(request.resource.data.title) &&
          // Validate description if provided (max 2000 chars)
          (!('description' in request.resource.data) ||
            (isValidString(request.resource.data.description, 0, 2000) &&
             isSafeString(request.resource.data.description))) &&
          // Validate priority if provided
          (!('priority' in request.resource.data) ||
            isValidPriority(request.resource.data.priority)) &&
          // Completed must be boolean
          request.resource.data.completed is bool &&
          // Audit fields
          request.resource.data.createdBy == request.auth.uid &&
          isCurrentTimestamp(request.resource.data.createdAt);

        // Update: with validation and audit fields
        allow update: if isSignedIn() &&
          request.auth.uid == userId &&
          isNotSoftDeleted() &&
          // Validate title if changed
          (!('title' in request.resource.data) ||
            (isValidString(request.resource.data.title, 1, 500) &&
             isSafeString(request.resource.data.title))) &&
          // Validate description if provided
          (!('description' in request.resource.data) ||
            (isValidString(request.resource.data.description, 0, 2000) &&
             isSafeString(request.resource.data.description))) &&
          // Validate priority if provided
          (!('priority' in request.resource.data) ||
            isValidPriority(request.resource.data.priority)) &&
          // Preserve immutable fields
          preservesImmutableFields(['createdAt', 'createdBy']) &&
          // Require update audit fields
          request.resource.data.updatedAt is timestamp &&
          request.resource.data.lastModifiedBy == request.auth.uid;

        // Delete: soft delete only
        allow delete: if isSignedIn() &&
          request.auth.uid == userId &&
          isNotSoftDeleted();
      }

      // ----------------------------------------
      // User Presets Subcollection
      // ----------------------------------------
      match /presets/{presetId} {
        allow read: if isSignedIn() && request.auth.uid == userId;

        allow create: if isSignedIn() &&
          request.auth.uid == userId &&
          // Required fields
          request.resource.data.keys().hasAll(['name', 'createdAt']) &&
          // Validate name (1-100 chars, safe string)
          isValidString(request.resource.data.name, 1, 100) &&
          isSafeString(request.resource.data.name) &&
          // Audit fields
          isCurrentTimestamp(request.resource.data.createdAt);

        allow update: if isSignedIn() &&
          request.auth.uid == userId &&
          // Validate name if changed
          (!('name' in request.resource.data) ||
            (isValidString(request.resource.data.name, 1, 100) &&
             isSafeString(request.resource.data.name))) &&
          // Preserve immutable fields
          preservesImmutableFields(['createdAt']) &&
          // Require update audit fields
          request.resource.data.updatedAt is timestamp;

        allow delete: if isSignedIn() && request.auth.uid == userId;
      }

      // ----------------------------------------
      // User Settings Subcollection
      // ----------------------------------------
      match /settings/{settingId} {
        allow read: if isSignedIn() && request.auth.uid == userId;

        allow create: if isSignedIn() &&
          request.auth.uid == userId &&
          request.resource.data.createdAt is timestamp;

        allow update: if isSignedIn() &&
          request.auth.uid == userId &&
          request.resource.data.updatedAt is timestamp;

        allow delete: if isSignedIn() && request.auth.uid == userId;
      }

      // ----------------------------------------
      // User Team Memberships Subcollection
      // ----------------------------------------
      match /teamMemberships/{teamId} {
        // Read own memberships
        allow read: if isSignedIn() && request.auth.uid == userId;

        // Create/update own memberships
        allow create, update: if isSignedIn() &&
          request.auth.uid == userId &&
          // Validate role
          isValidRole(request.resource.data.role) &&
          // Required fields
          request.resource.data.keys().hasAll(['teamId', 'role', 'joinedAt']);

        // Delete own memberships
        allow delete: if isSignedIn() && request.auth.uid == userId;
      }
    }

    // ============================================
    // SECTION 7: Team Rules
    // ============================================

    match /teams/{teamId} {
      // Read: team members only, not soft-deleted
      allow read: if isTeamMember(teamId) && isNotSoftDeleted();

      // Create: authenticated user with validation
      allow create: if isSignedIn() &&
        // Owner must be the creator
        request.resource.data.ownerId == request.auth.uid &&
        // Required fields
        request.resource.data.keys().hasAll(['name', 'ownerId', 'createdAt', 'createdBy']) &&
        // Validate team name (1-100 chars, safe string)
        isValidString(request.resource.data.name, 1, 100) &&
        isSafeString(request.resource.data.name) &&
        // Validate description if provided (max 500 chars)
        (!('description' in request.resource.data) ||
          (isValidString(request.resource.data.description, 0, 500) &&
           isSafeString(request.resource.data.description))) &&
        // Audit fields
        request.resource.data.createdBy == request.auth.uid &&
        isCurrentTimestamp(request.resource.data.createdAt) &&
        // Initial state: not deleted
        (!('isDeleted' in request.resource.data) || request.resource.data.isDeleted == false);

      // Update: admin or owner
      allow update: if isTeamAdmin(teamId) &&
        isNotSoftDeleted() &&
        // Validate team name if changed
        (!('name' in request.resource.data) ||
          (isValidString(request.resource.data.name, 1, 100) &&
           isSafeString(request.resource.data.name))) &&
        // Validate description if provided
        (!('description' in request.resource.data) ||
          (isValidString(request.resource.data.description, 0, 500) &&
           isSafeString(request.resource.data.description))) &&
        // Preserve immutable fields
        preservesImmutableFields(['ownerId', 'createdAt', 'createdBy']) &&
        // Require update audit fields
        request.resource.data.updatedAt is timestamp &&
        request.resource.data.lastModifiedBy == request.auth.uid &&
        // Prevent changing ownerId (privilege escalation prevention)
        request.resource.data.ownerId == resource.data.ownerId;

      // Soft Delete: owner only
      allow update: if isTeamOwner(teamId) &&
        isNotSoftDeleted() &&
        hasValidSoftDeleteFields() &&
        // Only allow setting isDeleted to true
        request.resource.data.isDeleted == true &&
        // Preserve other critical fields
        request.resource.data.ownerId == resource.data.ownerId;

      // Hard Delete: disabled (use soft delete)
      allow delete: if false;

      // ----------------------------------------
      // Team Members Subcollection
      // ----------------------------------------
      match /members/{memberId} {
        // Read: team members can see all members
        allow read: if isTeamMember(teamId) && isNotSoftDeleted();

        // Create: admin can add members, or user can add themselves via invitation
        allow create: if isSignedIn() && (
          // Admin adding a member
          (isTeamAdmin(teamId) &&
           // Cannot create owner role (privilege escalation prevention)
           request.resource.data.role != 'owner' &&
           isValidRole(request.resource.data.role) &&
           // Required audit fields
           request.resource.data.keys().hasAll(['role', 'joinedAt', 'addedBy']) &&
           request.resource.data.addedBy == request.auth.uid &&
           isCurrentTimestamp(request.resource.data.joinedAt)) ||
          // User adding themselves (self-join via invitation)
          (memberId == request.auth.uid &&
           request.resource.data.role in ['editor', 'viewer'] &&
           request.resource.data.keys().hasAll(['role', 'joinedAt']) &&
           isCurrentTimestamp(request.resource.data.joinedAt))
        );

        // Update: admin can update roles with restrictions
        allow update: if isTeamAdmin(teamId) &&
          // Cannot change owner's role (privilege escalation prevention)
          resource.data.role != 'owner' &&
          // Cannot promote to owner (privilege escalation prevention)
          request.resource.data.role != 'owner' &&
          // Validate new role
          isValidRole(request.resource.data.role) &&
          // Audit fields
          request.resource.data.updatedAt is timestamp &&
          request.resource.data.lastModifiedBy == request.auth.uid &&
          // Preserve immutable fields
          preservesImmutableFields(['joinedAt', 'addedBy']);

        // Delete: admin can remove non-owners, users can remove themselves
        allow delete: if isSignedIn() && (
          // Admin removing a member (but not the owner)
          (isTeamAdmin(teamId) && resource.data.role != 'owner') ||
          // User removing themselves (leaving the team, but owner cannot leave)
          (memberId == request.auth.uid && resource.data.role != 'owner')
        );
      }

      // ----------------------------------------
      // Team Todos Subcollection
      // ----------------------------------------
      match /todos/{todoId} {
        // Read: team members can read non-deleted todos
        allow read: if isTeamMember(teamId) && isNotSoftDeleted();

        // Create: owner, admin, or editor with validation
        allow create: if canEditTeamTodos(teamId) &&
          // Required fields
          request.resource.data.keys().hasAll(['title', 'completed', 'createdAt', 'createdBy']) &&
          // Creator must be current user
          request.resource.data.createdBy == request.auth.uid &&
          // Validate title (1-500 chars, safe string)
          isValidString(request.resource.data.title, 1, 500) &&
          isSafeString(request.resource.data.title) &&
          // Validate description if provided (max 2000 chars)
          (!('description' in request.resource.data) ||
            (isValidString(request.resource.data.description, 0, 2000) &&
             isSafeString(request.resource.data.description))) &&
          // Validate priority if provided
          (!('priority' in request.resource.data) ||
            isValidPriority(request.resource.data.priority)) &&
          // Completed must be boolean
          request.resource.data.completed is bool &&
          // Audit fields
          isCurrentTimestamp(request.resource.data.createdAt) &&
          // Initial state: not deleted
          (!('isDeleted' in request.resource.data) || request.resource.data.isDeleted == false);

        // Update: owner, admin, or editor with audit
        allow update: if canEditTeamTodos(teamId) &&
          isNotSoftDeleted() &&
          // Validate title if changed
          (!('title' in request.resource.data) ||
            (isValidString(request.resource.data.title, 1, 500) &&
             isSafeString(request.resource.data.title))) &&
          // Validate description if provided
          (!('description' in request.resource.data) ||
            (isValidString(request.resource.data.description, 0, 2000) &&
             isSafeString(request.resource.data.description))) &&
          // Validate priority if provided
          (!('priority' in request.resource.data) ||
            isValidPriority(request.resource.data.priority)) &&
          // Require update audit fields
          request.resource.data.updatedAt is timestamp &&
          request.resource.data.lastModifiedBy == request.auth.uid &&
          // Preserve immutable fields
          preservesImmutableFields(['createdAt', 'createdBy']);

        // Soft Delete: admin can soft-delete any, editor can soft-delete own
        allow update: if isSignedIn() &&
          isNotSoftDeleted() &&
          hasValidSoftDeleteFields() &&
          (isTeamAdmin(teamId) ||
           (canEditTeamTodos(teamId) && resource.data.createdBy == request.auth.uid));

        // Hard Delete: disabled (use soft delete)
        allow delete: if false;
      }

      // ----------------------------------------
      // Team Activity Log (Audit Trail)
      // ----------------------------------------
      match /activityLog/{logId} {
        // Read: team admins only (data leakage prevention)
        allow read: if isTeamAdmin(teamId);

        // Create: any team member can create activity logs
        allow create: if isTeamMember(teamId) &&
          // Required fields for audit
          request.resource.data.keys().hasAll(['action', 'userId', 'timestamp', 'details']) &&
          // User must be current user
          request.resource.data.userId == request.auth.uid &&
          // Timestamp must be current
          isCurrentTimestamp(request.resource.data.timestamp) &&
          // Action must be valid
          request.resource.data.action in [
            'todo_created', 'todo_updated', 'todo_deleted',
            'member_added', 'member_removed', 'member_role_changed',
            'team_updated', 'invitation_sent', 'invitation_accepted'
          ] &&
          // Details must be safe string if provided
          (!('details' in request.resource.data) ||
            isSafeString(request.resource.data.details));

        // Update/Delete: not allowed (immutable audit trail)
        allow update, delete: if false;
      }
    }

    // ============================================
    // SECTION 8: Invitation Rules
    // ============================================

    match /invitations/{invitationId} {
      // Read: creator, recipient (by email), or anyone for link invitations
      allow read: if isSignedIn() && (
        // Creator can read
        resource.data.createdBy == request.auth.uid ||
        // Recipient can read (by email)
        resource.data.email == request.auth.token.email ||
        // Link invitations are readable by anyone authenticated
        resource.data.type == 'link'
      ) && isNotSoftDeleted();

      // Create: authenticated users who are team admins with validation
      allow create: if isSignedIn() &&
        // Must be team admin
        isTeamAdmin(request.resource.data.teamId) &&
        // Required fields
        request.resource.data.keys().hasAll(['teamId', 'type', 'status', 'role', 'createdAt', 'createdBy', 'expiresAt']) &&
        // Creator must be current user
        request.resource.data.createdBy == request.auth.uid &&
        // Validate type
        isValidInvitationType(request.resource.data.type) &&
        // Validate status (must be pending on create)
        request.resource.data.status == 'pending' &&
        // Validate role (cannot invite as owner - privilege escalation prevention)
        request.resource.data.role in ['admin', 'editor', 'viewer'] &&
        // Validate email if provided
        (!('email' in request.resource.data) ||
          isValidEmail(request.resource.data.email)) &&
        // Audit fields
        isCurrentTimestamp(request.resource.data.createdAt) &&
        // Expiration must be in future (max 7 days)
        request.resource.data.expiresAt is timestamp &&
        request.resource.data.expiresAt > request.time &&
        request.resource.data.expiresAt <= request.time + duration.value(7, 'd') &&
        // Initial state: not deleted
        (!('isDeleted' in request.resource.data) || request.resource.data.isDeleted == false);

      // Update: status changes only with restrictions
      allow update: if isSignedIn() && isNotSoftDeleted() && (
        // Creator can cancel (status: cancelled)
        (resource.data.createdBy == request.auth.uid &&
         request.resource.data.status == 'cancelled' &&
         resource.data.status == 'pending') ||
        // Recipient can accept/decline
        ((resource.data.email == request.auth.token.email || resource.data.type == 'link') &&
         request.resource.data.status in ['accepted', 'declined'] &&
         resource.data.status == 'pending' &&
         // Check expiration
         resource.data.expiresAt > request.time)
      ) &&
        // Preserve immutable fields (data tampering prevention)
        preservesImmutableFields(['teamId', 'type', 'role', 'email', 'createdAt', 'createdBy', 'expiresAt']) &&
        // Status change audit
        request.resource.data.updatedAt is timestamp &&
        request.resource.data.lastModifiedBy == request.auth.uid;

      // Soft Delete: creator only
      allow update: if isSignedIn() &&
        resource.data.createdBy == request.auth.uid &&
        isNotSoftDeleted() &&
        hasValidSoftDeleteFields();

      // Hard Delete: disabled (use soft delete)
      allow delete: if false;
    }

    // ============================================
    // SECTION 9: Global Audit Log (Admin Only)
    // ============================================

    match /auditLog/{logId} {
      // Read: no client-side read (use Cloud Functions for admin access)
      allow read: if false;

      // Create: authenticated users can create audit entries
      allow create: if isSignedIn() &&
        request.resource.data.keys().hasAll(['action', 'userId', 'timestamp', 'resourceType', 'resourceId']) &&
        request.resource.data.userId == request.auth.uid &&
        isCurrentTimestamp(request.resource.data.timestamp) &&
        request.resource.data.action in [
          'login', 'logout', 'signup',
          'team_created', 'team_deleted',
          'sensitive_data_accessed', 'permission_changed'
        ];

      // Update/Delete: not allowed (immutable audit trail)
      allow update, delete: if false;
    }

    // ============================================
    // SECTION 10: Deny All Other Access
    // ============================================

    // Catch-all: deny access to any undefined paths
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
